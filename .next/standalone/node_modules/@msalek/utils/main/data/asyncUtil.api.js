"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.interactionFunctionCall = exports.handlePromiseWithTimeout = exports.useDebounce = exports.debounce = exports.freezeThreadAndWait = void 0;
var tslib_1 = require("tslib");
var react_1 = require("react");
var freezeThreadAndWait = function (delay) { return tslib_1.__awaiter(void 0, void 0, void 0, function () {
    return tslib_1.__generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve) {
                setTimeout(resolve, delay);
            })
            // Usage:
            // debounce(greeting, 3000)('Amit', 'the UK')
        ];
    });
}); };
exports.freezeThreadAndWait = freezeThreadAndWait;
// Usage:
// debounce(greeting, 3000)('Amit', 'the UK')
var debounce = function (callback, timeout) {
    var timer;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        clearTimeout(timer);
        timer = setTimeout(function () {
            callback.apply(void 0, args);
        }, timeout);
    };
};
exports.debounce = debounce;
function useDebounce(value, delay) {
    var _a = (0, react_1.useState)(value), debouncedValue = _a[0], setDebouncedValue = _a[1];
    (0, react_1.useEffect)(function () {
        var timer = setTimeout(function () { return setDebouncedValue(value); }, delay || 500);
        return function () {
            clearTimeout(timer);
        };
    }, [value, delay]);
    return debouncedValue;
}
exports.useDebounce = useDebounce;
var handlePromiseWithTimeout = function (promise_1) {
    var args_1 = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args_1[_i - 1] = arguments[_i];
    }
    return tslib_1.__awaiter(void 0, tslib_1.__spreadArray([promise_1], args_1, true), void 0, function (promise, ms, timeoutError) {
        var timeout;
        if (ms === void 0) { ms = 3000; }
        if (timeoutError === void 0) { timeoutError = new Error('@msalek/utils, handlePromiseWithTimeout: The timeout for a promise has passed.'); }
        return tslib_1.__generator(this, function (_a) {
            timeout = new Promise(function (_, reject) {
                setTimeout(function () {
                    reject(timeoutError);
                }, ms);
            });
            return [2 /*return*/, Promise.race([promise, timeout])];
        });
    });
};
exports.handlePromiseWithTimeout = handlePromiseWithTimeout;
var interactionFunctionCall = function (functionToFire) {
    var USER_EVENTS = ['scroll', 'keydown', 'pointerdown', 'pointermove', 'touchstart'];
    var innerRunOnce = false;
    function callbackClosure() {
        if (innerRunOnce) {
            return void undefined;
        }
        innerRunOnce = true;
        setTimeout(function () {
            functionToFire();
        }, 0);
        for (var i = 0; i < USER_EVENTS.length; i++) {
            document.removeEventListener(USER_EVENTS[i], callbackClosure);
        }
        return void undefined;
    }
    for (var i = 0; i < USER_EVENTS.length; i++) {
        document.addEventListener(USER_EVENTS[i], callbackClosure);
    }
};
exports.interactionFunctionCall = interactionFunctionCall;
//# sourceMappingURL=asyncUtil.api.js.map